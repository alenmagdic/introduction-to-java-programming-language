package hr.fer.zemris.bf.utils;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.function.BinaryOperator;

import hr.fer.zemris.bf.model.BinaryOperatorNode;
import hr.fer.zemris.bf.model.ConstantNode;
import hr.fer.zemris.bf.model.Node;
import hr.fer.zemris.bf.model.NodeVisitor;
import hr.fer.zemris.bf.model.UnaryOperatorNode;
import hr.fer.zemris.bf.model.VariableNode;

/**
 * A node visitor that evaluates the expression generated by the tree that is
 * visited.
 *
 * @author Alen MagdiÄ‡
 *
 */
public class ExpressionEvaluator implements NodeVisitor {
	/** An array of variable values **/
	private boolean[] values;
	/**
	 * A map that associates variable names with the position of their value in
	 * array of variable values.
	 **/
	private Map<String, Integer> positions;
	/** A stack used to evaulate the expression. **/
	private Stack<Boolean> stack = new Stack<>();

	/**
	 * Constructor.
	 *
	 * @param variables
	 *            list of variable names
	 */
	public ExpressionEvaluator(List<String> variables) {
		if (variables == null) {
			throw new IllegalArgumentException("null is not a legal argument");
		}

		positions = new HashMap<>();
		for (int i = 0, n = variables.size(); i < n; i++) {
			positions.put(variables.get(i), i);
		}
	}

	/**
	 * Sets variable values.
	 *
	 * @param values
	 *            variable values
	 */
	public void setValues(boolean[] values) {
		if (values.length != positions.size()) {
			throw new IllegalArgumentException(
					"Expected array of length " + positions.size() + " but given array of length " + values.length);
		}

		this.values = Arrays.copyOf(values, values.length);
		start();
	}

	@Override
	public void visit(ConstantNode node) {
		stack.push(node.getValue());
	}

	@Override
	public void visit(VariableNode node) {
		Integer varPosition = positions.get(node.getName());
		if (varPosition == null) {
			throw new IllegalStateException("Unknown variable name: " + node.getName());
		}
		stack.push(values[varPosition]);
	}

	@Override
	public void visit(UnaryOperatorNode node) {
		node.getChild().accept(this);
		boolean operandValue = stack.pop();
		stack.push(node.getOperator().apply(operandValue));
	}

	@Override
	public void visit(BinaryOperatorNode node) {
		for (Node child : node.getChildren()) {
			child.accept(this);
		}

		BinaryOperator<Boolean> oper = node.getOperator();
		boolean currentResult = oper.apply(stack.pop(), stack.pop());
		for (int i = 2, n = node.getChildren().size(); i < n; i++) {
			currentResult = oper.apply(stack.pop(), currentResult);
		}
		stack.push(currentResult);
	}

	/**
	 * Prepares for a new evaulation.
	 *
	 */
	public void start() {
		stack.clear();
	}

	/**
	 * Gets the result of last evaluation.
	 **/
	public boolean getResult() {
		if (stack.size() != 1) {
			throw new IllegalStateException("There is no result.");
		}
		return stack.peek();
	}

}
